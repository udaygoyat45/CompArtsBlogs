<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <title>ASCII Art in C++</title>
  <meta name="description" content="">
  <meta name="author" content="">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="//fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">

  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">

  <link rel="icon" type="image/png" href="images/favicon.png">

</head>
<body>

  <div class="container">
    <div class="row">
      <div class="one-half column" style="margin-top: 10%">
        <h2>ASCII Art</h2>
      </div>
    </div>

    <div class="row">
      <div>
        <h4>Libraries</h4>
        <p>In order to get started, first we need to install OpenCV and its dependencies. 
         Use your package manager to install the necessary libraries. Once you are done with
        the installation, we can finally create a cpp file to get started. </p>
      </div>
      <pre><code>touch ascii.cpp </code></pre> 
      <p>Then open your file with your favorite code editor. First we include all the necessaries files.</p>
      <pre><code class="prettyprint">#include &ltcstdio&gt
#include &ltstring&gt

#include &ltopencv2/imgcodecs.hpp&gt
#include &ltopencv2/videoio.hpp&gt

extern "C" 
{
#include &ltsys/ioctl.h&gt
#include &ltunistd.h&gt
}</code></pre>
    </div>

  <div class="row">
    <h4>Defining Structures</h4>  
    <p>First, we must define data structures for rgb values
      and the images we load. 
    </p>
    <pre><code class="prettyprint">struct RGB {
  int r, g, b;
}

struct View {
  int w, h;
}</code></pre>
</div>

<div class="row">
  <h4>Reading Files</h4>
  <p>We will utilize the command line argument to get the image file. 
    The first argument within argv will be the executable's name itself,
    the second argument will be the path to the image file.
  </p>
  
  <pre><code class="prettyprint"> int main (int argc, char* argv[]) {
if (argc <= 1) {
  std::fputs("no input image/video file specified.\n", stderr);
  std::fputs("usage: ascii [FILE]\n", stderr);
  return 1;
  }
  // more code
}</code></pre>
  
  <p>Additionally, in order to utilize the entire terminal's size, 
    we will read the terminal's height and width.
  </p>
  
  <pre><code class="prettyprint">/* get terminal size */
struct winsize ws;
ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws);
View view {ws.ws_col, ws.ws_row};</code></pre>
  
  <p>Finally, we will read the image. We make sure that the file is an image first of all (we will learn how to convert videos into ascii art in the next lesson. </p>
  <pre><code class="prettyprint">/* images */
std::string file {argv[1]};
if (cv::haveImageReader(file)) {
  cv::Mat im = cv::imread(argv[1]);
  displayFrame(im, view);
  std::getchar();
}</code></pre>
</div>

<div class="row">
  <h4>Processing Images</h4>
  <p>First we must write some helper function in order to extract the rgb values 
  at the certain coordinates. Additionally, we must keep in mind that OpenCV orders 
  pixels as BGR rather than RGB. We can define another structure to convert BGR to RGB and vice verse.
  </p> 
  <pre><code class="prettyprint">/* swizzling: how RGB data is extracted, ex. BGR -> RGB */
using Swiz = RGB;
static constexpr Swiz
	SWIZ_RGB = {0, 1, 2},
	SWIZ_BGR = {2, 1, 0};</code></pre>

<p>We can define a simple getPixel function as follows:</p>
<pre><code class="prettyprint">static void 
getPixel(
	RGB &px, 
	cv::Mat const &im,
	int x, 
	int y,
	Swiz const &sw = SWIZ_BGR
) {
	std::size_t off = im.channels() * (y * im.cols + x);
	px.r = im.data[off+sw.r];
	px.g = im.data[off+sw.g];
	px.b = im.data[off+sw.b];
}</code></pre>

<p>However, since the terminal size and the image size aren't gauranteed to match, 
  we need create another helper function that could maps the appropriate pixesls from the image
  to the terminal size. 
</p>

<pre><code class="prettyprint">static void 
getPixelV(
	RGB &px, 
	cv::Mat const &im,
	View const &view, 
	int x, 
	int y, 
	Swiz const &sw = SWIZ_BGR
) {
	/* nearest neighbor for now */
	x = (int)(x * (float) im.cols / view.w);
	y = (int)(y * (float) im.rows / view.h);
	getPixel(px, im, x, y, sw);
}</code></pre>

<p>Finally, we can the actual image to ascii art function.</p>
<pre><code class="prettyprint">static void
displayFrame(
	cv::Mat const &im,
	View const &view
) {
	std::printf("\033[1;1H");
	for (int y = 0; y < view.h; ++y) {
		for (int x = 0; x < view.w; ++x) {
			RGB px;
			getPixelV(px, im, view, x, y);
			std::printf("\033[48;2;%d;%d;%dm ", px.r, px.g, px.b);
		}
		std::puts("");
	}
	std::fflush(stdout);
}</code></pre>

</div>

<div class="row">
  <h4>Everything Combined</h4>
  <pre><code>#include &ltcstdio&gt
#include &ltstring&gt

#include &ltopencv2/imgcodecs.hpp&gt
#include &ltopencv2/videoio.hpp&gt

extern "C" 
{
#include &ltsys/ioctl.h&gt
#include &ltunistd.h&gt
}


struct RGB 
{
	int r, g, b;
};

/* swizzling: how RGB data is extracted, ex. BGR -> RGB */
using Swiz = RGB;
static constexpr Swiz
	SWIZ_RGB = {0, 1, 2},
	SWIZ_BGR = {2, 1, 0};

struct View
{
	int w, h;
};

static void 
getPixel(
	RGB &px, 
	cv::Mat const &im,
	int x, 
	int y,
	Swiz const &sw = SWIZ_BGR
) {
	std::size_t off = im.channels() * (y * im.cols + x);
	px.r = im.data[off+sw.r];
	px.g = im.data[off+sw.g];
	px.b = im.data[off+sw.b];
}

static void 
getPixelV(
	RGB &px, 
	cv::Mat const &im,
	View const &view, 
	int x, 
	int y, 
	Swiz const &sw = SWIZ_BGR
) {
	/* nearest neighbor for now */
	x = (int)(x * (float) im.cols / view.w);
	y = (int)(y * (float) im.rows / view.h);
	getPixel(px, im, x, y, sw);
}

static void
displayFrame(
	cv::Mat const &im,
	View const &view
) {
	std::printf("\033[1;1H");
	for (int y = 0; y < view.h; ++y) {
		for (int x = 0; x < view.w; ++x) {
			RGB px;
			getPixelV(px, im, view, x, y);
			std::printf("\033[48;2;%d;%d;%dm ", px.r, px.g, px.b);
		}
		std::puts("");
	}
	std::fflush(stdout);
}

int 
main(int argc, char* argv[]) 
{
	if (argc <= 1) {
		std::fputs("no input image/video file specified.\n", stderr);
		std::fputs("usage: ascii [FILE]\n", stderr);
		return 1;
	}

	/* use a large stdout buffer for the framebuffer */
	std::setvbuf(stdout, NULL, _IOFBF, 1 << 30); /* 1GB buffer */

	/* get terminal size */
	struct winsize ws;
	ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws);
	View view {ws.ws_col, ws.ws_row};

	/* images */
	std::string file {argv[1]};
	if (cv::haveImageReader(file)) {
		cv::Mat im = cv::imread(argv[1]);
		displayFrame(im, view);
		std::getchar();
	}

	return 0;
}</code></pre>
</div>

</body>

<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
</html>
